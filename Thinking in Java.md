# Thinking in Java
## 상속을 이용한 시스템 설계
  - 기존 클래스를 이용해 새클래스를 만들고자 할 때 상속 보다는 컴포지션을 먼저 고려하는 것이 좋다. 
  - 컴포지션 이용하면 실행할 때 동적으로 타입을 선택할 수 있어 유연성에 좋다. (스테이트 패턴)
  - 상속은 컴파일 할 때 정확한 타입을 알아야 한다. 
  - 행동의 차이를 표현하려면 상속을, 상태의 변화를 표현하려면 필드를 사용한다. 

## 인터페이스와 Foactory
  - 인터페이스에 적합한 객체를 생성하는 전형적인 방법은 Factory Method 패턴이다. 
  - 생성자를 직접 호출하는 대신 인터페이스를 구현하는 Factory 객체의 생성 메서드를 호출할 수 있다. 
  - 하나의 구현을 다른 구현으로 바꿀 수 있게 해준다.  

## 내부 클래스
  - 외곽 클래스에서 내부 클래스의 객체 참조를 반환하는 메서드를 갖는다. 
  - 외곽 클래스의 멤버 메서드에서는 내부 클래스의 객체를 바로 참조하거나 생성할 수 있다.
  - 그외의 곳에서는 반드시 외곽클래스명.내부클래스명의 형태로 해야 한다. 
  - 내부 클래스는 외곽 클래스의 모든 요소에 대해 접근 권한을 갖는다. 
  - 내부 클래스를 생성하려면 반드시 외각 클래스를 먼저 생헝한 후 그 참조를 통해 내부 클래스를 생성해야 한다. 
  - 외곽 클래스의 참조가 필요하면 '외곽클래스명.this'하면 된다. 
  - 내부클래스 생성은 외부 클래스의 함수 사용하는 법과 외곽 클래스 객체를 통한 new가 있다. 
  - 내부클래스는 인터페이스와 사용할 때 진가를 발휘한다.
    - 내부 클래스에서 인터페이스를 implements하면 인터페이스 구현을 숨길수 있다. 
  - 내부 클래스가 private로 지정됬으면 내부클래스를 가지고 있는 외각 클래스에서만 엑세스 가능하다. 
    - 내부 클래스가 아닌 일반 클래스는 proivate나 proteced에 접근 할 수 없다. 
    - private 내부 클래스는 클래스 설계자가 코드와의 종속성을 완벽하게 방지하고, 구현의 상세함을 완전하게 감출 수 있게 해 준다. 

### 메서드나 블록에서 내부 클래스 사용하기
  - 메서드나 블록(ex. if문 블록안의 클래스)에서의 클래스는 그 블록 안에서만 클래스에 접근가능하다. 
### 익명 내부 클래스
  - ㅇ
### 내부클래스는 왜 필요할까?
  - 내부 클래스에서는 외곽 클래스가 이미 상속 받고 있는 것에 제한되지 않고 별도로 또 다른 클래스로부터 상속 받을 수 있다. 
    - 다중 상속의 문제점 해결 보완책
  - 