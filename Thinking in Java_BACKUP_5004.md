# Thinking in Java
## 상속을 이용한 시스템 설계
<<<<<<< HEAD
  - 기존 클래스를 이용해 새클래스를 만들고자 할 때 상속 보다는 컴포지션을 먼저 고려하는 것이 좋다. 
  - 컴포지션 이용하면 실행할 때 동적으로 타입을 선택할 수 있어 유연성에 좋다. (스테이트 패턴)
  - 상속은 컴파일 할 때 정확한 타입을 알아야 한다. 
  - 행동의 차이를 표현하려면 상속을, 상태의 변화를 표현하려면 필드를 사용한다. 

## 인터페이스와 Foactory
  - 인터페이스에 적합한 객체를 생성하는 전형적인 방법은 Factory Method 패턴이다. 
  - 생성자를 직접 호출하는 대신 인터페이스를 구현하는 Factory 객체의 생성 메서드를 호출할 수 있다. 
  - 하나의 구현을 다른 구현으로 바꿀 수 있게 해준다.  

## 내부 클래스
  - 외곽 클래스에서 내부 클래스의 객체 참조를 반환하는 메서드를 갖는다. 
  - 외곽 클래스의 멤버 메서드에서는 내부 클래스의 객체를 바로 참조하거나 생성할 수 있다.
  - 그외의 곳에서는 반드시 외곽클래스명.내부클래스명의 형태로 해야 한다. 
  - 내부 클래스는 외곽 클래스의 모든 요소에 대해 접근 권한을 갖는다. 
  - 내부 클래스를 생성하려면 반드시 외각 클래스를 먼저 생헝한 후 그 참조를 통해 내부 클래스를 생성해야 한다. 
  - 외곽 클래스의 참조가 필요하면 '외곽클래스명.this'하면 된다. 
  - 내부클래스 생성은 외부 클래스의 함수 사용하는 법과 외곽 클래스 객체를 통한 new가 있다. 
  - 내부클래스는 인터페이스와 사용할 때 진가를 발휘한다.
    - 내부 클래스에서 인터페이스를 implements하면 인터페이스 구현을 숨길수 있다. 
  - 내부 클래스가 private로 지정됬으면 내부클래스를 가지고 있는 외각 클래스에서만 엑세스 가능하다. 
    - 내부 클래스가 아닌 일반 클래스는 proivate나 proteced에 접근 할 수 없다. 
    - private 내부 클래스는 클래스 설계자가 코드와의 종속성을 완벽하게 방지하고, 구현의 상세함을 완전하게 감출 수 있게 해 준다. 

### 메서드나 블록에서 내부 클래스 사용하기
  - 메서드나 블록(ex. if문 블록안의 클래스)에서의 클래스는 그 블록 안에서만 클래스에 접근가능하다. 
### 익명 내부 클래스
  - ㅇ
### 내부클래스는 왜 필요할까?
  - 내부 클래스에서는 외곽 클래스가 이미 상속 받고 있는 것에 제한되지 않고 별도로 또 다른 클래스로부터 상속 받을 수 있다. 
    - 다중 상속의 문제점 해결 보완책
  - 
=======

## 문자열
### StringBuilder
  - 루프 내에서 String의 '+'를 쓰면 루프 내에서 StringBuilder가 계속 생성된다. 
    - 효율성 좀 떨어짐.
  - 루프 내에서 StringBuilder로 연결하면 하나의 StringBuilder 객체만 생성된다. 
  - 루프에서는 StringBuilder를 사용하자. 
### Formmater
  - Formatter f = new Formatter(System.out);  // 생성할떄 생성자 인자에는 보낼 위치를 넣는다. 
  - f.format("%-15s %5s %10.2f\n", name, qty, price); // c의 printf와 비슷하다. 
  - String.format()이 있는데, String을 반호나한다. format()을 한 번 호출할 필요가 있을때만 편리하다.
### 정규표현식
  - 정규표현식 기본
    - 정규표현식은 일반화된 형태로 문자열을 나타애는 방법이다. 따라서 '문자열 안에 이것들이 있으면, 내가 찾는것과 일치한다'라고 할수 있다.
    - 숫자 표현 '\d'를 표현하려면 '\\\\d' (2개적는거임, md가인식못해서 4개표시햇음) 라고 적어야 한다. 
    - 정규표현식을 간단하게 사용하는 방법은 String 클래스에 내장된 기능을 사용하는 것이다. matches("-?\\\\d+")
    - '?'부호는 다음에 나올수도 있고 안나올 수도 있고의 표시
    - '+'부호는 하나 이상의 이전 수식을 나타내기 위함. '+'는 정규표현식에서 특별한 의미를 가져서 '\\\\+'로 표시해야 한다. 
    - String의 split()은 '지정된 정규표현식과 일치하는 문자의 주변 문자열을 분리하라'의 의미다. 
    - String 클래스의 마지막 정규표현 식은 변경이다. replaceFirst(), replaceAll()
    - String이 아닌 정규표현식이 더 강력한 변경도구가 된다. 
  - Pattern과 Matcher
    - static Pattern.compile()해서 정규표현식을 컴파일하면 그 메서드의 String 인자를 기반으로 Pattern 객체로 생성된다.
    - 우리가 원하는 문자열을 matcher() 메서드의 인자로 전달하여 호출함으로써 Pattern 객체를 사용한다. 

  - StringTokenizer
    - Scanner 클래스가 나오기 전에 문자열 분할 방법으로 사용. 
    - 이제는 정규표현식과 Scanner 클래스를 사용해 더 쉽고 간결하게 사용가능
>>>>>>> 823ece6d5a054bd9a9fad3b0e9061344c55d5e1f
